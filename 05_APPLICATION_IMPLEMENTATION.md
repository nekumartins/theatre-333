# Online Theatre Booking System - Application Implementation Guide

## FastAPI + HTML/Tailwind Frontend Integration

---

## 1. Technology Stack Overview

### 1.1 Backend
- **Framework**: FastAPI (Python 3.9+)
- **Database Driver**: MySQL Connector Python or aiomysql (async)
- **ORM**: SQLAlchemy (optional but recommended)
- **Authentication**: JWT (JSON Web Tokens)
- **Password Hashing**: bcrypt or Argon2

### 1.2 Frontend
- **HTML5**: Semantic markup
- **Tailwind CSS**: Utility-first CSS framework
- **JavaScript**: Vanilla JS or Alpine.js for interactivity
- **HTMX** (optional): For dynamic content without heavy JavaScript

### 1.3 Additional Tools
- **Database Migrations**: Alembic
- **API Documentation**: Auto-generated by FastAPI (Swagger/OpenAPI)
- **Environment Variables**: python-dotenv

---

## 2. Project Structure

```
theatre-booking/
â”‚
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py                 # FastAPI application entry point
â”‚   â”‚   â”œâ”€â”€ database.py             # Database connection
â”‚   â”‚   â”œâ”€â”€ models.py               # SQLAlchemy models
â”‚   â”‚   â”œâ”€â”€ schemas.py              # Pydantic schemas
â”‚   â”‚   â”œâ”€â”€ crud.py                 # Database operations
â”‚   â”‚   â”œâ”€â”€ auth.py                 # Authentication logic
â”‚   â”‚   â”œâ”€â”€ routers/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ users.py
â”‚   â”‚   â”‚   â”œâ”€â”€ shows.py
â”‚   â”‚   â”‚   â”œâ”€â”€ performances.py
â”‚   â”‚   â”‚   â”œâ”€â”€ bookings.py
â”‚   â”‚   â”‚   â””â”€â”€ payments.py
â”‚   â”‚   â””â”€â”€ utils.py
â”‚   â”œâ”€â”€ alembic/                    # Database migrations
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ .env
â”‚
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ static/
â”‚   â”‚   â”œâ”€â”€ css/
â”‚   â”‚   â”‚   â””â”€â”€ styles.css
â”‚   â”‚   â””â”€â”€ js/
â”‚   â”‚       â””â”€â”€ app.js
â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â”œâ”€â”€ base.html
â”‚   â”‚   â”œâ”€â”€ index.html              # Home page
â”‚   â”‚   â”œâ”€â”€ shows.html              # Browse shows
â”‚   â”‚   â”œâ”€â”€ performance_detail.html # Seat selection
â”‚   â”‚   â”œâ”€â”€ booking_summary.html    # Booking review
â”‚   â”‚   â”œâ”€â”€ payment.html            # Payment page
â”‚   â”‚   â”œâ”€â”€ confirmation.html       # Booking confirmation
â”‚   â”‚   â”œâ”€â”€ my_bookings.html        # User booking history
â”‚   â”‚   â””â”€â”€ login.html              # User login
â”‚   â””â”€â”€ tailwind.config.js
â”‚
â””â”€â”€ README.md
```

---

## 3. Database Connection (FastAPI)

### 3.1 `database.py`
```python
from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
import os
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL", "mysql+pymysql://user:password@localhost/theatre_booking")

engine = create_engine(
    DATABASE_URL,
    pool_pre_ping=True,
    pool_recycle=3600,
    echo=False
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

Base = declarative_base()

# Dependency
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

### 3.2 `.env` File
```env
DATABASE_URL=mysql+pymysql://root:yourpassword@localhost:3306/theatre_booking
SECRET_KEY=your-secret-key-here-generate-random
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30
```

---

## 4. Sample SQLAlchemy Models

### 4.1 `models.py` (Excerpt)
```python
from sqlalchemy import Column, Integer, String, Text, Date, Time, DECIMAL, TIMESTAMP, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class User(Base):
    __tablename__ = "user"
    
    user_id = Column(Integer, primary_key=True, autoincrement=True)
    first_name = Column(String(50), nullable=False)
    last_name = Column(String(50), nullable=False)
    email = Column(String(100), unique=True, nullable=False, index=True)
    phone = Column(String(20))
    password_hash = Column(String(255), nullable=False)
    account_status = Column(String(20), default="Active")
    created_at = Column(TIMESTAMP, server_default=func.now())
    
    # Relationships
    bookings = relationship("Booking", back_populates="user")

class Show(Base):
    __tablename__ = "show_table"
    
    show_id = Column(Integer, primary_key=True, autoincrement=True)
    title = Column(String(200), nullable=False)
    description = Column(Text)
    genre_id = Column(Integer, ForeignKey("genre.genre_id"), nullable=False)
    duration_minutes = Column(Integer, nullable=False)
    show_status = Column(String(20), default="Active")
    poster_url = Column(String(255))
    
    # Relationships
    genre = relationship("Genre")
    performances = relationship("Performance", back_populates="show")

class Performance(Base):
    __tablename__ = "performance"
    
    performance_id = Column(Integer, primary_key=True, autoincrement=True)
    show_id = Column(Integer, ForeignKey("show_table.show_id"), nullable=False)
    venue_id = Column(Integer, ForeignKey("venue.venue_id"), nullable=False)
    performance_date = Column(Date, nullable=False)
    start_time = Column(Time, nullable=False)
    total_seats = Column(Integer, nullable=False)
    available_seats = Column(Integer, nullable=False)
    performance_status = Column(String(20), default="Scheduled")
    
    # Relationships
    show = relationship("Show", back_populates="performances")
    venue = relationship("Venue")
    bookings = relationship("Booking", back_populates="performance")
    pricing = relationship("PerformancePricing", back_populates="performance")

class Booking(Base):
    __tablename__ = "booking"
    
    booking_id = Column(Integer, primary_key=True, autoincrement=True)
    user_id = Column(Integer, ForeignKey("user.user_id"), nullable=False)
    performance_id = Column(Integer, ForeignKey("performance.performance_id"), nullable=False)
    booking_reference = Column(String(20), unique=True, nullable=False)
    booking_date = Column(TIMESTAMP, server_default=func.now())
    total_amount = Column(DECIMAL(10, 2), nullable=False)
    booking_status = Column(String(20), default="Pending")
    
    # Relationships
    user = relationship("User", back_populates="bookings")
    performance = relationship("Performance", back_populates="bookings")
    booking_details = relationship("BookingDetail", back_populates="booking")
    payments = relationship("Payment", back_populates="booking")
```

---

## 5. Key FastAPI Endpoints (API Routes)

### 5.1 User Authentication (`routers/users.py`)
```python
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from passlib.context import CryptContext
from jose import JWTError, jwt
from datetime import datetime, timedelta
import schemas, models, database

router = APIRouter(prefix="/api/users", tags=["Users"])
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

@router.post("/register", status_code=status.HTTP_201_CREATED)
def register_user(user: schemas.UserCreate, db: Session = Depends(database.get_db)):
    """Register a new user"""
    # Check if email exists
    existing_user = db.query(models.User).filter(models.User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Hash password
    hashed_password = pwd_context.hash(user.password)
    
    # Create user
    new_user = models.User(
        first_name=user.first_name,
        last_name=user.last_name,
        email=user.email,
        password_hash=hashed_password,
        registration_date=datetime.now().date()
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)
    
    return {"message": "User registered successfully", "user_id": new_user.user_id}

@router.post("/login")
def login(credentials: schemas.UserLogin, db: Session = Depends(database.get_db)):
    """User login and JWT token generation"""
    user = db.query(models.User).filter(models.User.email == credentials.email).first()
    
    if not user or not pwd_context.verify(credentials.password, user.password_hash):
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    # Generate JWT token
    access_token = create_access_token(data={"sub": user.email})
    
    return {"access_token": access_token, "token_type": "bearer"}
```

---

### 5.2 Browse Shows (`routers/shows.py`)
```python
from fastapi import APIRouter, Depends, Query
from sqlalchemy.orm import Session
import models, database

router = APIRouter(prefix="/api/shows", tags=["Shows"])

@router.get("/")
def get_shows(
    genre: str = None,
    status: str = "Active",
    db: Session = Depends(database.get_db)
):
    """Retrieve all active shows, optionally filter by genre"""
    query = db.query(models.Show).filter(models.Show.show_status == status)
    
    if genre:
        query = query.join(models.Genre).filter(models.Genre.genre_name == genre)
    
    shows = query.all()
    return shows

@router.get("/{show_id}")
def get_show_detail(show_id: int, db: Session = Depends(database.get_db)):
    """Get detailed information about a specific show"""
    show = db.query(models.Show).filter(models.Show.show_id == show_id).first()
    if not show:
        raise HTTPException(status_code=404, detail="Show not found")
    return show
```

---

### 5.3 Get Performances (`routers/performances.py`)
```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from datetime import date
import models, database

router = APIRouter(prefix="/api/performances", tags=["Performances"])

@router.get("/show/{show_id}")
def get_performances_for_show(show_id: int, db: Session = Depends(database.get_db)):
    """Get all upcoming performances for a specific show"""
    performances = db.query(models.Performance).filter(
        models.Performance.show_id == show_id,
        models.Performance.performance_date >= date.today(),
        models.Performance.performance_status == "Scheduled"
    ).all()
    
    return performances

@router.get("/{performance_id}/seats")
def get_available_seats(performance_id: int, db: Session = Depends(database.get_db)):
    """Get seat availability for a specific performance"""
    performance = db.query(models.Performance).filter(
        models.Performance.performance_id == performance_id
    ).first()
    
    if not performance:
        raise HTTPException(status_code=404, detail="Performance not found")
    
    # Get all seats for the venue
    all_seats = db.query(models.Seat).filter(
        models.Seat.venue_id == performance.venue_id,
        models.Seat.is_active == True
    ).all()
    
    # Get already booked seats
    booked_seats = db.query(models.BookingDetail.seat_id).join(
        models.Booking
    ).filter(
        models.Booking.performance_id == performance_id,
        models.Booking.booking_status.in_(["Pending", "Confirmed"])
    ).all()
    
    booked_seat_ids = [seat[0] for seat in booked_seats]
    
    # Mark seats as available or booked
    seat_map = []
    for seat in all_seats:
        seat_map.append({
            "seat_id": seat.seat_id,
            "row": seat.row_number,
            "number": seat.seat_number,
            "category": seat.seat_category,
            "is_booked": seat.seat_id in booked_seat_ids
        })
    
    return {"performance_id": performance_id, "seats": seat_map}
```

---

### 5.4 Create Booking (`routers/bookings.py`)
```python
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from datetime import datetime
import random, string
import models, schemas, database

router = APIRouter(prefix="/api/bookings", tags=["Bookings"])

def generate_booking_reference():
    """Generate unique booking reference"""
    timestamp = datetime.now().strftime("%Y%m%d%H%M%S")
    random_str = ''.join(random.choices(string.ascii_uppercase + string.digits, k=4))
    return f"BK{timestamp}{random_str}"

@router.post("/", status_code=201)
def create_booking(
    booking_data: schemas.BookingCreate,
    db: Session = Depends(database.get_db)
):
    """Create a new booking with selected seats"""
    # Validate performance exists
    performance = db.query(models.Performance).filter(
        models.Performance.performance_id == booking_data.performance_id
    ).first()
    
    if not performance:
        raise HTTPException(status_code=404, detail="Performance not found")
    
    # Check seat availability
    for seat_id in booking_data.seat_ids:
        existing_booking = db.query(models.BookingDetail).join(
            models.Booking
        ).filter(
            models.BookingDetail.seat_id == seat_id,
            models.Booking.performance_id == booking_data.performance_id,
            models.Booking.booking_status.in_(["Pending", "Confirmed"])
        ).first()
        
        if existing_booking:
            raise HTTPException(status_code=400, detail=f"Seat {seat_id} already booked")
    
    # Calculate total amount
    total = 0
    seat_details = []
    for seat_id in booking_data.seat_ids:
        seat = db.query(models.Seat).filter(models.Seat.seat_id == seat_id).first()
        price_obj = db.query(models.PerformancePricing).filter(
            models.PerformancePricing.performance_id == booking_data.performance_id,
            models.PerformancePricing.seat_category == seat.seat_category
        ).first()
        
        total += price_obj.price
        seat_details.append({
            "seat_id": seat_id,
            "price": price_obj.price,
            "row": seat.row_number,
            "number": seat.seat_number,
            "category": seat.seat_category
        })
    
    # Create booking
    new_booking = models.Booking(
        user_id=booking_data.user_id,
        performance_id=booking_data.performance_id,
        booking_reference=generate_booking_reference(),
        total_amount=total,
        booking_status="Pending"
    )
    db.add(new_booking)
    db.flush()
    
    # Create booking details
    for detail in seat_details:
        booking_detail = models.BookingDetail(
            booking_id=new_booking.booking_id,
            seat_id=detail["seat_id"],
            seat_price=detail["price"],
            row_number=detail["row"],
            seat_number=detail["number"],
            seat_category=detail["category"]
        )
        db.add(booking_detail)
    
    # Update available seats
    performance.available_seats -= len(booking_data.seat_ids)
    
    db.commit()
    db.refresh(new_booking)
    
    return {
        "booking_id": new_booking.booking_id,
        "booking_reference": new_booking.booking_reference,
        "total_amount": float(new_booking.total_amount)
    }
```

---

## 6. Frontend Forms and Templates

### 6.1 Base Template (`templates/base.html`)
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Theatre Booking System{% endblock %}</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-50">
    <!-- Navigation -->
    <nav class="bg-indigo-600 text-white p-4">
        <div class="container mx-auto flex justify-between items-center">
            <a href="/" class="text-2xl font-bold">ðŸŽ­ Theatre Booking</a>
            <div class="space-x-4">
                <a href="/shows" class="hover:underline">Shows</a>
                <a href="/my-bookings" class="hover:underline">My Bookings</a>
                <a href="/login" class="hover:underline">Login</a>
            </div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="container mx-auto mt-8 px-4">
        {% block content %}{% endblock %}
    </main>

    <!-- Footer -->
    <footer class="bg-gray-800 text-white text-center p-4 mt-12">
        <p>&copy; 2025 Theatre Booking System. All rights reserved.</p>
    </footer>

    {% block scripts %}{% endblock %}
</body>
</html>
```

---

### 6.2 Show Listing Page (`templates/shows.html`)
```html
{% extends "base.html" %}

{% block title %}Browse Shows{% endblock %}

{% block content %}
<h1 class="text-4xl font-bold mb-8">Available Shows</h1>

<div class="grid grid-cols-1 md:grid-cols-3 gap-6">
    {% for show in shows %}
    <div class="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-xl transition">
        <img src="{{ show.poster_url or '/static/placeholder.jpg' }}" alt="{{ show.title }}" class="w-full h-48 object-cover">
        <div class="p-4">
            <h2 class="text-2xl font-semibold mb-2">{{ show.title }}</h2>
            <p class="text-gray-600 mb-2">{{ show.genre.genre_name }}</p>
            <p class="text-sm text-gray-500 mb-4">{{ show.duration_minutes }} minutes</p>
            <a href="/shows/{{ show.show_id }}" class="bg-indigo-600 text-white px-4 py-2 rounded hover:bg-indigo-700">
                View Details
            </a>
        </div>
    </div>
    {% endfor %}
</div>
{% endblock %}
```

---

### 6.3 Seat Selection Page (`templates/performance_detail.html`)
```html
{% extends "base.html" %}

{% block title %}Select Seats{% endblock %}

{% block content %}
<h1 class="text-3xl font-bold mb-4">{{ show.title }}</h1>
<p class="text-gray-600 mb-8">{{ performance.performance_date }} at {{ performance.start_time }}</p>

<div class="bg-white p-6 rounded-lg shadow-md">
    <h2 class="text-2xl font-semibold mb-4">Select Your Seats</h2>
    
    <!-- Seat Map -->
    <div class="grid grid-cols-10 gap-2 mb-6">
        {% for seat in seats %}
        <div 
            class="seat p-2 text-center border rounded cursor-pointer
                   {% if seat.is_booked %}bg-gray-300 cursor-not-allowed{% else %}bg-green-100 hover:bg-green-200{% endif %}"
            data-seat-id="{{ seat.seat_id }}"
            data-price="{{ seat.price }}"
            {% if seat.is_booked %}disabled{% endif %}>
            {{ seat.row }}{{ seat.number }}
        </div>
        {% endfor %}
    </div>

    <!-- Legend -->
    <div class="flex space-x-4 mb-6">
        <div class="flex items-center">
            <div class="w-6 h-6 bg-green-100 border mr-2"></div>
            <span>Available</span>
        </div>
        <div class="flex items-center">
            <div class="w-6 h-6 bg-gray-300 border mr-2"></div>
            <span>Booked</span>
        </div>
        <div class="flex items-center">
            <div class="w-6 h-6 bg-blue-200 border mr-2"></div>
            <span>Selected</span>
        </div>
    </div>

    <!-- Selected Seats Summary -->
    <div id="summary" class="bg-gray-100 p-4 rounded mb-4">
        <p>Selected Seats: <span id="selected-seats">None</span></p>
        <p>Total: $<span id="total-price">0.00</span></p>
    </div>

    <button id="book-btn" class="bg-indigo-600 text-white px-6 py-3 rounded hover:bg-indigo-700 disabled:bg-gray-400" disabled>
        Proceed to Payment
    </button>
</div>
{% endblock %}

{% block scripts %}
<script>
    let selectedSeats = [];
    let totalPrice = 0;

    document.querySelectorAll('.seat:not([disabled])').forEach(seat => {
        seat.addEventListener('click', function() {
            const seatId = this.dataset.seatId;
            const price = parseFloat(this.dataset.price);

            if (this.classList.contains('bg-blue-200')) {
                // Deselect
                this.classList.remove('bg-blue-200');
                this.classList.add('bg-green-100');
                selectedSeats = selectedSeats.filter(id => id !== seatId);
                totalPrice -= price;
            } else {
                // Select
                this.classList.remove('bg-green-100');
                this.classList.add('bg-blue-200');
                selectedSeats.push(seatId);
                totalPrice += price;
            }

            updateSummary();
        });
    });

    function updateSummary() {
        document.getElementById('selected-seats').textContent = selectedSeats.length > 0 ? selectedSeats.length : 'None';
        document.getElementById('total-price').textContent = totalPrice.toFixed(2);
        document.getElementById('book-btn').disabled = selectedSeats.length === 0;
    }

    document.getElementById('book-btn').addEventListener('click', function() {
        // Send booking request to API
        fetch('/api/bookings/', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                user_id: {{ current_user.user_id }},
                performance_id: {{ performance.performance_id }},
                seat_ids: selectedSeats
            })
        })
        .then(response => response.json())
        .then(data => {
            if (data.booking_id) {
                window.location.href = `/payment/${data.booking_id}`;
            }
        });
    });
</script>
{% endblock %}
```

---

## 7. Essential SQL Queries with Explanations

### 7.1 Query 1: Get All Available Performances with Show Details
**Purpose**: Display upcoming shows with venue and pricing information for the homepage.

```sql
SELECT 
    p.performance_id,
    s.title AS show_title,
    s.poster_url,
    g.genre_name,
    v.venue_name,
    v.city,
    p.performance_date,
    p.start_time,
    p.available_seats,
    MIN(pp.price) AS min_price,
    MAX(pp.price) AS max_price
FROM performance p
JOIN show_table s ON p.show_id = s.show_id
JOIN genre g ON s.genre_id = g.genre_id
JOIN venue v ON p.venue_id = v.venue_id
LEFT JOIN performance_pricing pp ON p.performance_id = pp.performance_id
WHERE p.performance_date >= CURDATE()
  AND p.performance_status = 'Scheduled'
  AND p.available_seats > 0
GROUP BY p.performance_id, s.title, s.poster_url, g.genre_name, 
         v.venue_name, v.city, p.performance_date, p.start_time, p.available_seats
ORDER BY p.performance_date, p.start_time;
```

**Explanation**: 
- Retrieves upcoming performances with show, genre, and venue details
- Calculates minimum and maximum ticket prices for each performance
- Filters only scheduled performances with available seats
- Useful for homepage "What's On" section

---

### 7.2 Query 2: User Booking History with Full Details
**Purpose**: Display a customer's complete booking history with payment status.

```sql
SELECT 
    b.booking_id,
    b.booking_reference,
    b.booking_date,
    s.title AS show_title,
    v.venue_name,
    p.performance_date,
    p.start_time,
    GROUP_CONCAT(CONCAT(bd.row_number, bd.seat_number) SEPARATOR ', ') AS seats,
    b.total_amount,
    b.booking_status,
    pay.payment_status,
    pay.payment_date
FROM booking b
JOIN performance p ON b.performance_id = p.performance_id
JOIN show_table s ON p.show_id = s.show_id
JOIN venue v ON p.venue_id = v.venue_id
JOIN booking_detail bd ON b.booking_id = bd.booking_id
LEFT JOIN payment pay ON b.booking_id = pay.booking_id AND pay.payment_status = 'Completed'
WHERE b.user_id = ? -- Replace with actual user ID
GROUP BY b.booking_id, b.booking_reference, b.booking_date, s.title, 
         v.venue_name, p.performance_date, p.start_time, b.total_amount, 
         b.booking_status, pay.payment_status, pay.payment_date
ORDER BY b.booking_date DESC;
```

**Explanation**: 
- Retrieves all bookings for a specific user
- Concatenates seat information into a single string
- Joins with payment table to show payment status
- Orders by most recent bookings first
- Used in "My Bookings" page

---

### 7.3 Query 3: Revenue Report by Show and Date Range
**Purpose**: Generate sales analytics for business reporting (admin dashboard).

```sql
SELECT 
    s.title AS show_title,
    g.genre_name,
    COUNT(DISTINCT b.booking_id) AS total_bookings,
    SUM(bd.seat_price) AS total_revenue,
    COUNT(bd.booking_detail_id) AS tickets_sold,
    AVG(bd.seat_price) AS avg_ticket_price,
    v.venue_name,
    p.performance_date
FROM booking b
JOIN booking_detail bd ON b.booking_id = bd.booking_id
JOIN performance p ON b.performance_id = p.performance_id
JOIN show_table s ON p.show_id = s.show_id
JOIN genre g ON s.genre_id = g.genre_id
JOIN venue v ON p.venue_id = v.venue_id
WHERE b.booking_status = 'Confirmed'
  AND p.performance_date BETWEEN '2025-12-01' AND '2025-12-31'
GROUP BY s.title, g.genre_name, v.venue_name, p.performance_date
ORDER BY total_revenue DESC;
```

**Explanation**: 
- Calculates total revenue, number of bookings, and tickets sold per show
- Filters only confirmed bookings within a date range
- Groups by show and performance date
- Provides average ticket price for pricing analysis
- Critical for business intelligence and reporting

---

### 7.4 Query 4: Seat Occupancy Rate by Performance
**Purpose**: Analyze venue utilization and popular performances.

```sql
SELECT 
    p.performance_id,
    s.title AS show_title,
    v.venue_name,
    p.performance_date,
    p.start_time,
    p.total_seats,
    p.available_seats,
    (p.total_seats - p.available_seats) AS seats_booked,
    ROUND(((p.total_seats - p.available_seats) / p.total_seats) * 100, 2) AS occupancy_rate
FROM performance p
JOIN show_table s ON p.show_id = s.show_id
JOIN venue v ON p.venue_id = v.venue_id
WHERE p.performance_status IN ('Scheduled', 'Completed')
ORDER BY occupancy_rate DESC;
```

**Explanation**: 
- Calculates occupancy percentage for each performance
- Identifies high-demand shows
- Helps in pricing strategy and scheduling decisions
- Useful for capacity planning

---

### 7.5 Query 5: Find Seats Available for Specific Performance with Pricing
**Purpose**: Real-time seat availability check with pricing for booking process.

```sql
SELECT 
    s.seat_id,
    s.row_number,
    s.seat_number,
    s.section,
    s.seat_category,
    s.is_accessible,
    pp.price,
    CASE 
        WHEN bd.booking_detail_id IS NOT NULL THEN 'Booked'
        ELSE 'Available'
    END AS seat_status
FROM seat s
JOIN performance p ON s.venue_id = p.venue_id
LEFT JOIN performance_pricing pp ON p.performance_id = pp.performance_id 
    AND s.seat_category = pp.seat_category
LEFT JOIN booking_detail bd ON s.seat_id = bd.seat_id
LEFT JOIN booking b ON bd.booking_id = b.booking_id 
    AND b.performance_id = p.performance_id
    AND b.booking_status IN ('Pending', 'Confirmed')
WHERE p.performance_id = ? -- Replace with actual performance ID
  AND s.is_active = TRUE
ORDER BY s.row_number, s.seat_number;
```

**Explanation**: 
- Retrieves all seats for a venue with their current status
- Joins with bookings to determine if seat is already booked
- Includes pricing from PERFORMANCE_PRICING table
- Essential for seat selection interface
- Filters only active seats

---

## 8. Recommended Forms and Reports

### 8.1 Essential Forms
1. **User Registration Form**
   - Fields: First Name, Last Name, Email, Password, Phone, City
   - Validation: Email format, password strength

2. **Login Form**
   - Fields: Email, Password
   - JWT token generation upon successful login

3. **Seat Selection Form**
   - Interactive seat map (JavaScript)
   - Visual feedback for available/booked/selected seats
   - Real-time price calculation

4. **Payment Form**
   - Fields: Card Number, Expiry, CVV, Cardholder Name
   - Integration with payment gateway API
   - Secure transmission (HTTPS)

5. **Booking Cancellation Form**
   - Display booking details
   - Confirm cancellation
   - Calculate refund amount based on policy

### 8.2 Essential Reports
1. **Daily Sales Report**
   - Total revenue by date
   - Number of bookings
   - Top-selling shows

2. **Performance Summary Report**
   - Occupancy rates
   - Revenue per performance
   - Seat category breakdown

3. **Customer Booking Report**
   - User-specific booking history
   - Total spent
   - Upcoming bookings

4. **Venue Utilization Report**
   - Bookings per venue
   - Peak times
   - Revenue by venue

---

## 9. Security Best Practices

1. **Password Security**
   - Use bcrypt or Argon2 for hashing
   - Never store plain-text passwords

2. **SQL Injection Prevention**
   - Use parameterized queries (SQLAlchemy ORM)
   - Validate all user inputs

3. **Authentication**
   - Implement JWT for stateless authentication
   - Set appropriate token expiration times

4. **HTTPS**
   - Use SSL/TLS certificates
   - Redirect HTTP to HTTPS

5. **Payment Security**
   - Comply with PCI DSS standards
   - Never store full credit card numbers
   - Use tokenization from payment gateways

---

## 10. Deployment Checklist

- [ ] Set up MySQL database on production server
- [ ] Configure environment variables (.env file)
- [ ] Run database migrations (Alembic)
- [ ] Set up HTTPS with SSL certificate
- [ ] Configure CORS for frontend-backend communication
- [ ] Implement rate limiting to prevent abuse
- [ ] Set up error logging and monitoring
- [ ] Create database backups schedule
- [ ] Test all API endpoints
- [ ] Optimize database queries with proper indexing

---

## Document Control
- **Version**: 1.0
- **Date**: November 24, 2025
- **Technology**: FastAPI, MySQL, HTML, Tailwind CSS
- **Purpose**: Academic Project - Application Implementation Guide
